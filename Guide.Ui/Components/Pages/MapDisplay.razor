@page "/map-example"
@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration 
@implements IDisposable 

<h3>Карта 2ГИС</h3>

<div id="mapContainerFor2Gis" style="width: 100%; height: 600px; border: 1px solid #ccc;">
    Загрузка карты...
</div>

@code {
    private string mapContainerId = "mapContainerFor2Gis";
    private string apiKey2Gis;
    private DotNetObjectReference<MapDisplay> dotNetObjectReference;

    protected override async Task OnInitializedAsync()
    {
        apiKey2Gis = Configuration["2Gis:ApiKey"];
        if (string.IsNullOrEmpty(apiKey2Gis))
        {
            Console.WriteLine("2GIS API Key not found in configuration.");
            // Обработка ошибки - ключ не найден
        }

        dotNetObjectReference = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !string.IsNullOrEmpty(apiKey2Gis))
        {
            try
            {
                // Вызов initMap остается таким же
                var initMessage = await JSRuntime.InvokeAsync<string>("initMap",
                    mapContainerId,
                    apiKey2Gis,
                    46.3497,
                    48.0302,
                    13,
                    dotNetObjectReference);
                Console.WriteLine($"JS initMap call returned: {initMessage}"); // Логируем ответ

                // НЕ НУЖНО вызывать AddMarker/DrawRoute немедленно здесь, если initMap
                // может быть отложен. Лучше иметь отдельный метод для "загрузки данных на карту",
                // который вызывается ПОСЛЕ того, как мы уверены, что карта инициализирована.
                // Но для простоты пока оставим. Если initMap отложится, эти вызовы могут упасть,
                // так как mapInstance еще не будет создан.

                // Это более безопасный подход:
                // if (initMessage.Contains("successfully")) // или другой признак успешной немедленной инициализации
                // {
                //    await LoadMapContent();
                // }
                // else if (initMessage.Contains("queued"))
                // {
                //    // Можно подождать или иметь механизм, когда JS уведомит C# о фактической инициализации
                // }
            }
            catch (JSException ex)
            {
                Console.WriteLine($"JS Interop Error: {ex.Message}");
            }
            catch (Exception ex) // Общий Exception для других возможных ошибок
            {
                Console.WriteLine($"Error in OnAfterRenderAsync: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task NotifyMapReadyAndLoadContent()
    {
        Console.WriteLine("C#: Map is reported as ready by JS. Loading content.");
        await AddMarker(46.3497, 48.0302, "Астраханский Кремль");
        var routePointsLngLat = new List<List<double>>
        {
            new List<double> { 48.0302, 46.3497 },
            new List<double> { 48.0350, 46.3550 },
            new List<double> { 48.0400, 46.3520 }
        };
        await DrawRoute(routePointsLngLat);
    }

    public async Task AddMarker(double lat, double lng, string popupText = null)
    {
        if (!string.IsNullOrEmpty(apiKey2Gis))
        {
            // JS функция addMarkerToMap ожидает (lat, lng, popupText)
            // а внутри себя она передаст в new mapgl.Marker(map, { coordinates: [lng, lat] })
            await JSRuntime.InvokeVoidAsync("addMarkerToMap", lat, lng, popupText);
        }
    }

    // points должен быть List<List<double>> где каждый внутренний List это [lng, lat]
    public async Task DrawRoute(List<List<double>> pointsLngLat)
    {
        if (!string.IsNullOrEmpty(apiKey2Gis))
        {
            await JSRuntime.InvokeVoidAsync("drawRouteOnMap", pointsLngLat);
        }
    }

    public async Task SetView(double lat, double lng, int zoom)
    {
        if (!string.IsNullOrEmpty(apiKey2Gis))
        {
            // JS функция setMapView ожидает (lat, lng, zoom)
            // а внутри себя она вызовет mapInstance.setCenter([lng, lat])
            await JSRuntime.InvokeVoidAsync("setMapView", lat, lng, zoom);
        }
    }

    // ... (ClearMap и Dispose остаются, но ClearMap потребует доработки в JS)

    // Метод, который будет вызван из JavaScript при клике по карте
    // JS теперь передает lat, lng в правильном порядке
    [JSInvokable]
    public async Task OnMapClicked(double lat, double lng)
    {
        Console.WriteLine($"MapGL clicked at Lat: {lat}, Lng: {lng}");
        await AddMarker(lat, lng, $"Клик: {lat:F4}, {lng:F4}");
    }

    public void Dispose()
    {
        dotNetObjectReference?.Dispose();
        // Вызов JS для очистки карты, если это необходимо при уничтожении компонента
        // Это важно, чтобы избежать утечек памяти, особенно если карта создается и удаляется многократно
        if (!string.IsNullOrEmpty(apiKey2Gis))
        {
            // Оборачиваем в try-catch, так как JSRuntime может быть недоступен на этом этапе
            try
            {
                JSRuntime.InvokeVoidAsync("disposeMap").AsTask();
            }
            catch
            {
            }
        }

        GC.SuppressFinalize(this);
    }

}